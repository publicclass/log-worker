
var lib = new Blob([
  // console.js
  "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction Console(stdout, stderr) {\n  if (!(this instanceof Console)) {\n    return new Console(stdout, stderr);\n  }\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new TypeError('Console expects a writable stream instance');\n  }\n  if (!stderr) {\n    stderr = stdout;\n  }\n  var prop = {\n    writable: true,\n    enumerable: false,\n    configurable: true\n  };\n  prop.value = stdout;\n  Object.defineProperty(this, '_stdout', prop);\n  prop.value = stderr;\n  Object.defineProperty(this, '_stderr', prop);\n  prop.value = {};\n  Object.defineProperty(this, '_times', prop);\n\n  // bind the prototype functions to this Console instance\n  Object.keys(Console.prototype).forEach(function(k) {\n    this[k] = this[k].bind(this);\n  }, this);\n}\n\nConsole.prototype.log = function() {\n  this._stdout.write(util.format.apply(this, arguments) + '\\n');\n};\n\n\nConsole.prototype.info = Console.prototype.log;\n\n\nConsole.prototype.warn = function() {\n  this._stderr.write(util.format.apply(this, arguments) + '\\n');\n};\n\n\nConsole.prototype.error = Console.prototype.warn;\n\n\nConsole.prototype.dir = function(object) {\n  this._stdout.write(util.inspect(object) + '\\n');\n};\n\n\nConsole.prototype.time = function(label) {\n  this._times[label] = Date.now();\n};\n\n\nConsole.prototype.timeEnd = function(label) {\n  var time = this._times[label];\n  if (!time) {\n    throw new Error('No such label: ' + label);\n  }\n  var duration = Date.now() - time;\n  this.log('%s: %dms', label, duration);\n};\n\n\nConsole.prototype.trace = function() {\n  // TODO probably can to do this better with V8's debug object once that is\n  // exposed.\n  var err = new Error;\n  err.name = 'Trace';\n  err.message = util.format.apply(this, arguments);\n  Error.captureStackTrace(err, arguments.callee);\n  this.error(err.stack);\n};\n\n\nConsole.prototype.assert = function(expression) {\n  if (!expression) {\n    throw new Error('assertion error...')\n  }\n};\n//@ sourceURL=log-worker/console.js",
  // util.js
  "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n(function(exports){\n\n  var formatRegExp = /%[sdj%]/g;\n  exports.format = function(f) {\n    if (typeof f !== 'string') {\n      var objects = [];\n      for (var i = 0; i < arguments.length; i++) {\n        objects.push(inspect(arguments[i]));\n      }\n      return objects.join(' ');\n    }\n\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    var str = String(f).replace(formatRegExp, function(x) {\n      if (x === '%%') return '%';\n      if (i >= len) return x;\n      switch (x) {\n        case '%s': return String(args[i++]);\n        case '%d': return Number(args[i++]);\n        case '%j': return JSON.stringify(args[i++]);\n        default:\n          return x;\n      }\n    });\n    for (var x = args[i]; i < len; x = args[++i]) {\n      if (x === null || typeof x !== 'object') {\n        str += ' ' + x;\n      } else {\n        str += ' ' + inspect(x);\n      }\n    }\n    return str;\n  };\n\n\n  /**\n   * Echos the value of a value. Trys to print the value out\n   * in the best way possible given the different types.\n   *\n   * @param {Object} obj The object to print out.\n   * @param {Object} opts Optional options object that alters the output.\n   */\n  /* legacy: obj, showHidden, depth, colors*/\n  function inspect(obj, opts) {\n    // default options\n    var ctx = {\n      seen: [],\n      stylize: stylizeNoColor\n    };\n    // legacy...\n    if (arguments.length >= 3) ctx.depth = arguments[2];\n    if (arguments.length >= 4) ctx.colors = arguments[3];\n    if (typeof opts === 'boolean') {\n      // legacy...\n      ctx.showHidden = opts;\n    } else if (opts) {\n      // got an \"options\" object\n      exports._extend(ctx, opts);\n    }\n    // set default options\n    if (typeof ctx.showHidden === 'undefined') ctx.showHidden = false;\n    if (typeof ctx.depth === 'undefined') ctx.depth = 2;\n    if (typeof ctx.colors === 'undefined') ctx.colors = false;\n    if (typeof ctx.customInspect === 'undefined') ctx.customInspect = true;\n    if (ctx.colors) ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n  }\n  exports.inspect = inspect;\n\n\n  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n  inspect.colors = {\n    'bold' : [1, 22],\n    'italic' : [3, 23],\n    'underline' : [4, 24],\n    'inverse' : [7, 27],\n    'white' : [37, 39],\n    'grey' : [90, 39],\n    'black' : [30, 39],\n    'blue' : [34, 39],\n    'cyan' : [36, 39],\n    'green' : [32, 39],\n    'magenta' : [35, 39],\n    'red' : [31, 39],\n    'yellow' : [33, 39]\n  };\n\n  // Don't use 'blue' not visible on cmd.exe\n  inspect.styles = {\n    'special': 'cyan',\n    'number': 'yellow',\n    'boolean': 'yellow',\n    'undefined': 'grey',\n    'null': 'bold',\n    'string': 'green',\n    'date': 'magenta',\n    // \"name\": intentionally not styling\n    'regexp': 'red'\n  };\n\n\n  function stylizeWithColor(str, styleType) {\n    var style = inspect.styles[styleType];\n\n    if (style) {\n      return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n             '\\u001b[' + inspect.colors[style][1] + 'm';\n    } else {\n      return str;\n    }\n  }\n\n\n  function stylizeNoColor(str, styleType) {\n    return str;\n  }\n\n\n  function arrayToHash(array) {\n    var hash = {};\n\n    array.forEach(function(val, idx) {\n      hash[val] = true;\n    });\n\n    return hash;\n  }\n\n\n  function formatValue(ctx, value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (ctx.customInspect && value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value.inspect !== exports.inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return String(value.inspect(recurseTimes));\n    }\n\n    // Primitive types cannot have properties\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n      return primitive;\n    }\n\n    // Look up the keys of the object.\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n\n    if (ctx.showHidden) {\n      keys = Object.getOwnPropertyNames(value);\n    }\n\n    // Some type of object without properties can be shortcutted.\n    if (keys.length === 0) {\n      if (typeof value === 'function') {\n        var name = value.name ? ': ' + value.name : '';\n        return ctx.stylize('[Function' + name + ']', 'special');\n      }\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      }\n      if (isDate(value)) {\n        return ctx.stylize(Date.prototype.toString.call(value), 'date');\n      }\n      if (isError(value)) {\n        return formatError(value);\n      }\n    }\n\n    var base = '', array = false, braces = ['{', '}'];\n\n    // Make Array say that they are Array\n    if (isArray(value)) {\n      array = true;\n      braces = ['[', ']'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = ' [Function' + n + ']';\n    }\n\n    // Make RegExps say that they are RegExps\n    if (isRegExp(value)) {\n      base = ' ' + RegExp.prototype.toString.call(value);\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + Date.prototype.toUTCString.call(value);\n    }\n\n    // Make error with message first say the error\n    if (isError(value)) {\n      base = ' ' + formatError(value);\n    }\n\n    if (keys.length === 0 && (!array || value.length == 0)) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n      } else {\n        return ctx.stylize('[Object]', 'special');\n      }\n    }\n\n    ctx.seen.push(value);\n\n    var output;\n    if (array) {\n      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n      output = keys.map(function(key) {\n        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n      });\n    }\n\n    ctx.seen.pop();\n\n    return reduceToSingleString(output, base, braces);\n  }\n\n\n  function formatPrimitive(ctx, value) {\n    switch (typeof value) {\n      case 'undefined':\n        return ctx.stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return ctx.stylize(simple, 'string');\n\n      case 'number':\n        return ctx.stylize('' + value, 'number');\n\n      case 'boolean':\n        return ctx.stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return ctx.stylize('null', 'null');\n    }\n  }\n\n\n  function formatError(value) {\n    return '[' + Error.prototype.toString.call(value) + ']';\n  }\n\n\n  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i < l; ++i) {\n      if (hasOwnProperty(value, String(i))) {\n        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n            String(i), true));\n      } else {\n        output.push('');\n      }\n    }\n    keys.forEach(function(key) {\n      if (!key.match(/^\\d+$/)) {\n        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n            key, true));\n      }\n    });\n    return output;\n  }\n\n\n  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n    if (desc.get) {\n      if (desc.set) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (desc.set) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n      name = '[' + key + ']';\n    }\n    if (!str) {\n      if (ctx.seen.indexOf(desc.value) < 0) {\n        if (recurseTimes === null) {\n          str = formatValue(ctx, desc.value, null);\n        } else {\n          str = formatValue(ctx, desc.value, recurseTimes - 1);\n        }\n        if (str.indexOf('\\n') > -1) {\n          if (array) {\n            str = str.split('\\n').map(function(line) {\n              return '  ' + line;\n            }).join('\\n').substr(2);\n          } else {\n            str = '\\n' + str.split('\\n').map(function(line) {\n              return '   ' + line;\n            }).join('\\n');\n          }\n        }\n      } else {\n        str = ctx.stylize('[Circular]', 'special');\n      }\n    }\n    if (typeof name === 'undefined') {\n      if (array && key.match(/^\\d+$/)) {\n        return str;\n      }\n      name = JSON.stringify('' + key);\n      if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n        name = name.substr(1, name.length - 2);\n        name = ctx.stylize(name, 'name');\n      } else {\n        name = name.replace(/'/g, \"\\\\'\")\n                   .replace(/\\\\\"/g, '\"')\n                   .replace(/(^\"|\"$)/g, \"'\");\n        name = ctx.stylize(name, 'string');\n      }\n    }\n\n    return name + ': ' + str;\n  }\n\n\n  function reduceToSingleString(output, base, braces) {\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 60) {\n      return braces[0] +\n             (base === '' ? '' : base + '\\n ') +\n             ' ' +\n             output.join(',\\n  ') +\n             ' ' +\n             braces[1];\n    }\n\n    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n  }\n\n\n  // NOTE: These type checking functions intentionally don't use `instanceof`\n  // because it is fragile and can be easily faked with `Object.create()`.\n  function isArray(ar) {\n    return Array.isArray(ar) ||\n           (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n  }\n  exports.isArray = isArray;\n\n\n  function isRegExp(re) {\n    return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n  }\n  exports.isRegExp = isRegExp;\n\n\n  function isDate(d) {\n    return typeof d === 'object' && objectToString(d) === '[object Date]';\n  }\n  exports.isDate = isDate;\n\n\n  function isError(e) {\n    return typeof e === 'object' && objectToString(e) === '[object Error]';\n  }\n  exports.isError = isError;\n\n\n  function objectToString(o) {\n    return Object.prototype.toString.call(o);\n  }\n\n\n  function pad(n) {\n    return n < 10 ? '0' + n.toString(10) : n.toString(10);\n  }\n\n\n  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n                'Oct', 'Nov', 'Dec'];\n\n  // 26 Feb 16:19:34\n  function timestamp() {\n    var d = new Date();\n    var time = [pad(d.getHours()),\n                pad(d.getMinutes()),\n                pad(d.getSeconds())].join(':');\n    return [d.getDate(), months[d.getMonth()], time].join(' ');\n  }\n\n\n  exports._extend = function(origin, add) {\n    // Don't do anything if add isn't an object\n    if (!add || typeof add !== 'object') return origin;\n\n    var keys = Object.keys(add);\n    var i = keys.length;\n    while (i--) {\n      origin[keys[i]] = add[keys[i]];\n    }\n    return origin;\n  };\n\n  function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n})(util = {});//@ sourceURL=log-worker/util.js",
  // log-worker.js
  "\nvar console\n  , name;\n\nself.onmessage = function(e){\n  if( !e.data ) return;\n  switch(e.data.type){\n    case 'log':\n    case 'info':\n    case 'warn':\n    case 'error':\n    case 'dir':\n    case 'time':\n    case 'timeEnd':\n    case 'trace':\n    case 'assert':\n      console[e.data.type].apply(console,e.data.args);\n      break\n    case 'location': location(e.data); break\n    default: throw new Error('unknown type: '+e.data.type)\n  }\n}\n\nfunction location(obj){\n  // set log name\n  var lastSlash = obj.pathname.lastIndexOf('/')\n    , lastPeriod = obj.pathname.lastIndexOf('.');\n  name = obj.pathname.slice(lastSlash+1,lastPeriod)+'.log';\n\n  // import scripts\n  var base = obj.origin + obj.pathname.slice(0,lastSlash);\n  importScripts(base+'/util.js',base+'/console.js')\n  var stdout = {\n    write: function(data){\n      write(new Blob([data], {type: 'text/plain'}))\n    }\n  }\n  console = new Console(stdout)\n}\n\nfunction open(name){\n  var fs = self.webkitRequestFileSystemSync(TEMPORARY,1024*1024*5);\n  var file = fs.root.getFile(name,{create:true})\n  return writer = file.createWriter();\n}\n\nfunction write(buffer){\n  // have to re-open or the length will not match...\n  var writer = open(name || 'log.txt')\n  writer.seek(writer.length)\n  writer.write(buffer);\n}\n//@ sourceURL=log-worker/log-worker.js"
])

var open = false;
var worker = new Worker(URL.createObjectURL(lib))
worker.addEventListener('error',function(e){
  open = false;
  console.error(e);
})
worker.postMessage({
  type: 'location',
  hash: location.hash,
  host: location.host,
  hostname: location.hostname,
  href: location.href,
  origin: location.origin,
  pathname: location.pathname,
  port: location.port,
  protocol: location.protocol,
  search: location.search
})

'log info warn error dir time timeEnd trace assert'.split(' ').forEach(register)
function register(name){
  exports[name] = function(){
    open && worker.postMessage({type:name, args: [].slice.call(arguments) })
  }
}
